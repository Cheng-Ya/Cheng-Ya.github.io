---
layout:     post
title:      "Git基础及常用命令(一)"
subtitle:   ""
date:       2018-07-09
author:     "Cheng"
header-img: "img/post-bg-about-Jekyll.webp"
tags:
    - Git基础
---

# 基础原理

## 直接记录快照，而非差异比较

Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。

![img-1.1](https://git-scm.com/book/en/v2/images/deltas.png)

Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。

![img-1.2](https://git-scm.com/book/en/v2/images/snapshots.png)

## 近乎所有操作都是本地执行

对于刚开始使用 Git 的同学来说，可能会分不清楚哪一些操作是本地操作，而哪些操作和远程服务器相关。举个简单的例子，部分同学可能认为使用 ```git commit``` 命令后，文件就提交并已经保存在远程服务器了，或者以为如果只使用 ```git commit``` 命令但没有使用 ```git push``` 命令的情况下，文件并没有被有效的保存。实际上，在 Git 中近乎所有操作都是本地执行。在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息(已经clone或者fetch了最新版本的情况下)。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。

形成迷惑的一部分原因可能是初学者在学习 Git 的使用时，大部分的教程都会将 ```git commit``` 和 ```git push``` 命令结合在一起进行讲解，这有利于更快的上手 Git 使用并将其应用到工作中去，实际的开发流程也确实可以无脑 ```git commit``` 后进行 ```git push``` ，但现在看来，这种讲解方式对于理解本地操作和远程操作或许会产生迷惑。

具体来说，在常用的命令里面， ```git push``` ```git pull``` ```git fetch``` ```git clone``` 等命令会和远程服务器发生实际的交互，也意味着如果远程服务器发生故障或者本地网络故障，则无法正常使上述命令。 ```git add <file name>``` ```git commit``` ```git merge``` ```git stash``` ```git stash pop``` 等命令都是基于 Git 本地数据库进行操作的，即以上命令完全可以在机器离线的情况下完成。


## Git 一般只添加数据

你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。


## Git 的三种状态

理解 Git 的三种状态很重要。 Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个 已修改文件的当前版本做了标记，使之包含在下次提交的快照中。

由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。

![img-1.3](https://git-scm.com/book/en/v2/images/areas.png)

Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。

工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。

暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。

基本的 Git 工作流程如下：
1. 在工作目录中修改文件。
2. 暂存文件，将文件的快照放入暂存区域。
3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。

如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。

# 日常开发流程和常用命令

##### 注：本文中使用的所有命令都通过命令行实现，且基于 ubuntn 设备的终端进行命令输入


## 初始化\克隆 Git 仓库

有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。

### 克隆 Git 仓库

考虑到在实际的工作开发过程中，Git 仓库的初始化都是由项目负责人来维护的，大部分的开发人员只需要等待项目创建完毕后在进行clone操作就好了，因此着重讲解clone操作。

如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，开发组有了新的项目，项目负责人已经为每个开发人员安排了具体的开发任务并为该项目初始化了 Git 仓库，那么你将首先使用 ```git clone``` 命令拷贝远程服务器上的新建项目。当然你也可以直接通过储存介质直接去你同事\老大的机器上拷贝已经初始化好的整个项目(一定是整个项目，特别是要完整的拷贝 ```.git``` 文件夹)或者直接Download Git 仓库中的项目压缩包，这和你使用 ```git clone``` 命令得到的项目近乎相同，你仍然可以对直接拷贝过来的项目使用 ```git add <file name>``` 命令暂存文件或者其他命令对文件进行操作。但考虑到我们正在使用 Git ,使用直接拷贝的方法显得很落后，而且一点也不geek，所以除非在你们的远程服务器已经挂掉了的情况下，不建议这样做。

克隆仓库的命令格式是 ```git clone [url]``` 。下面是使用命令行克隆 Git 仓库的过程。我们假设你要克隆神奇的 [shadowsocks](https://github.com/shadowsocks) 项目，你已经通过你可爱的同事知道了该项目的git地址为: https://github.com/shadowsocks/shadowsocks.git ，你决定将该项目克隆到你的 ```workspace``` 文件夹，那么首先你应该 ```cd``` 到 ```workspace``` 文件夹(假设 ```workspace``` 文件夹在 ```home``` 目录中)，命令如下

```
$ cd ~/workspace
$ git clone https://github.com/shadowsocks/shadowsocks.git
```

正常过程:

```
Cloning into 'shadowsocks'...
remote: Counting objects: 3632, done.
remote: Total 3632 (delta 0), reused 0 (delta 0), pack-reused 3632
Receiving objects: 100% (3632/3632), 923.47 KiB | 135.00 KiB/s, done.
Resolving deltas: 100% (2423/2423), done.
Checking connectivity... done.
```

使用 ```ls``` 命令，你可以在 ```workspace``` 文件夹中看到你刚刚克隆下来的 ```shadowsocks``` 文件夹。

你也可以自定义本地仓库的名字，例如你想让 ```shadowsocks``` 项目在克隆到本地时，被命名为 ```amazing``` ，那么你可以使用如下命令

```
$ git clone https://github.com/shadowsocks/shadowsocks.git amazing
```

这将执行与上一个命令相同的操作，不过在本地创建的项目名字变为 ```amazing``` 。

Git 支持多种数据传输协议。 上面的例子使用的是 ```https://``` 协议，不过你也可以使用 ```git://``` 协议或者使用 SSH 传输协议，比如 ```git@github.com:shadowsocks/shadowsocks.git``` 。使用 SSH 传输协议需要配置相应的 SSH key，后面我们将提到配置的方式。

考虑到 [shadowsocks](https://github.com/shadowsocks) 项目并未对普通用户开放完整的操作权限，而后面我们需要学习 ```git push```等会和远程仓库发生交互的命令，因此我们使用前面学习到的知识，克隆一个完全开放了操作权限的项目(我们命名该仓库为 ```测试仓库``` )，在后面的内容中，所有和远程仓库的交互都将和 ```测试仓库``` 进行。

我们将使用 ```git://``` 协议克隆 ```测试仓库``` 到 ```workspace```文件夹中

```
$ cd ~/workspace
$ git clone git@github.com:Cheng-Ya/git_study_test.git
```

使用 ```ls``` 命令，你会看到名为 ```git_study_test``` 的文件夹。

### 初始化仓库

如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：

```
$ git init
```

该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。

如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交：

```
$ git add .
$ git add SOME_FILE
$ git commit -m 'first commit'
```

后面我们再逐一解释每一条指令的意思。 现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的 Git 仓库。

参考: [Git手册](https://git-scm.com/book/zh/v2)